// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: campaigns.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCampaign = `-- name: CreateCampaign :one
INSERT INTO campaigns (name, channel, status, base_template, scheduled_at)
VALUES ($1, $2, $3, $4, $5) 
RETURNING id, name, channel, status, base_template, scheduled_at, created_at, updated_at
`

type CreateCampaignParams struct {
	Name         string           `json:"name"`
	Channel      string           `json:"channel"`
	Status       string           `json:"status"`
	BaseTemplate string           `json:"base_template"`
	ScheduledAt  pgtype.Timestamp `json:"scheduled_at"`
}

func (q *Queries) CreateCampaign(ctx context.Context, arg *CreateCampaignParams) (*Campaign, error) {
	row := q.db.QueryRow(ctx, createCampaign,
		arg.Name,
		arg.Channel,
		arg.Status,
		arg.BaseTemplate,
		arg.ScheduledAt,
	)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Channel,
		&i.Status,
		&i.BaseTemplate,
		&i.ScheduledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getCampaign = `-- name: GetCampaign :one
SELECT
    c.id, c.name, c.channel, c.status, c.base_template, c.scheduled_at, c.created_at, c.updated_at,
    jsonb_build_object(
        'total_messages', COALESCE(COUNT(om.id), 0),
        'pending',        COALESCE(SUM(CASE WHEN om.status = 'pending' THEN 1 ELSE 0 END), 0),
        'sent',           COALESCE(SUM(CASE WHEN om.status = 'sent' THEN 1 ELSE 0 END), 0),
        'failed',         COALESCE(SUM(CASE WHEN om.status = 'failed' THEN 1 ELSE 0 END), 0)
    ) AS stats
FROM campaigns c
LEFT JOIN outbound_messages om ON om.campaign_id = c.id
WHERE c.id = $1
GROUP BY c.id
`

type GetCampaignRow struct {
	ID           int64            `json:"id"`
	Name         string           `json:"name"`
	Channel      string           `json:"channel"`
	Status       string           `json:"status"`
	BaseTemplate string           `json:"base_template"`
	ScheduledAt  pgtype.Timestamp `json:"scheduled_at"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	Stats        []byte           `json:"stats"`
}

func (q *Queries) GetCampaign(ctx context.Context, campaignID int64) (*GetCampaignRow, error) {
	row := q.db.QueryRow(ctx, getCampaign, campaignID)
	var i GetCampaignRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Channel,
		&i.Status,
		&i.BaseTemplate,
		&i.ScheduledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Stats,
	)
	return &i, err
}

const listCampaigns = `-- name: ListCampaigns :many
SELECT
    c.id, c.name, c.channel, c.status, c.base_template, c.scheduled_at, c.created_at, c.updated_at,
    COUNT(*) OVER() AS total_count
FROM campaigns c
WHERE
    ($1::text IS NULL OR c.status = $1)
    AND ($2::text IS NULL OR c.channel = $2)
ORDER BY id DESC
LIMIT $4
OFFSET (($3- 1) * $4)
`

type ListCampaignsParams struct {
	Status     string      `json:"status"`
	Channel    string      `json:"channel"`
	PageNumber interface{} `json:"-page_number"`
	PageSize   int32       `json:"page_size"`
}

type ListCampaignsRow struct {
	ID           int64            `json:"id"`
	Name         string           `json:"name"`
	Channel      string           `json:"channel"`
	Status       string           `json:"status"`
	BaseTemplate string           `json:"base_template"`
	ScheduledAt  pgtype.Timestamp `json:"scheduled_at"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	TotalCount   int64            `json:"total_count"`
}

func (q *Queries) ListCampaigns(ctx context.Context, arg *ListCampaignsParams) ([]*ListCampaignsRow, error) {
	rows, err := q.db.Query(ctx, listCampaigns,
		arg.Status,
		arg.Channel,
		arg.PageNumber,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListCampaignsRow
	for rows.Next() {
		var i ListCampaignsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Channel,
			&i.Status,
			&i.BaseTemplate,
			&i.ScheduledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
